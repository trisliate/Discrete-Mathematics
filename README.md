# 离散数学实验 - 完整项目

> 包含5个独立的C程序，实现离散数学中关系与函数的各种操作

## 📁 项目文件

```
离散数学/
├── exp1_关系概念.c          实验1：关系的概念
├── exp2_关系性质.c          实验2：关系的性质
├── exp3_关系复合.c          实验3：关系的复合运算
├── exp4_关系闭包.c          实验4：关系的闭包
├── exp5_函数判定.c          实验5：函数的定义与类型
└── README.md               本文件
```

## 🚀 快速开始

### 在Dev-C++中运行
1. 打开 Dev-C++
2. File → Open → 选择任一 `exp*.c` 文件
3. 按 **F11** 编译并运行
4. 按照提示输入数据

---

## 📋 各实验说明

### 实验1：关系的概念 (`exp1_关系概念.c`)

**功能**：
- 输入集合A和集合B
- 输入从A到B的关系R的序偶
- 输出：
  - (1) 关系R的集合表达式
  - (2) 关系矩阵
  - (3) 定义域 domR
  - (4) 值域 ranR

**输入示例**（支持数字和字母）：
```
输入集合A的元素个数: 3
依次输入集合A的各元素 (空格分隔，可以是数字或字母): a b c
输入集合B的元素个数: 3
依次输入集合B的各元素 (空格分隔，可以是数字或字母): 1 2 3

输入关系R中序偶的个数: 5
输入关系的序偶 (格式: a b):
第1个序偶: a 1
第2个序偶: a 2
第3个序偶: b 2
第4个序偶: b 3
第5个序偶: c 1
```

**输出示例**：
```
========================================
【关系R的集合表达式】
R = {<a,1>, <a,2>, <b,2>, <b,3>, <c,1>}

【关系矩阵 M(R)】
       1    2    3
  a    1    1    0
  b    0    1    1
  c    1    0    0

【定义域 domR】
domR = {a, b, c}

【值域 ranR】
ranR = {1, 2, 3}
========================================
```

---

### 实验2：关系的性质 (`exp2_关系性质.c`)

**功能**：
- 输入集合A和A上的关系R（**同一个集合上的关系**）
- 输出关系矩阵
- 判定并输出：
  - (1) 是否为自反关系
  - (2) 是否为反自反关系
  - (3) 是否为对称关系
  - (4) 是否为反对称关系
  - (5) 是否为传递关系

**关系性质对照表**：

| 性质 | 定义 | 判定方法 |
|------|------|--------|
| 自反 | ∀a∈A, <a,a>∈R | 主对角线全为1 |
| 反自反 | ∀a∈A, <a,a>∉R | 主对角线全为0 |
| 对称 | <a,b>∈R ⟹ <b,a>∈R | 矩阵为对称矩阵 |
| 反对称 | <a,b>∈R ∧ <b,a>∈R ⟹ a=b | 不同位置不能同时为1 |
| 传递 | <a,b>∈R ∧ <b,c>∈R ⟹ <a,c>∈R | 若M[i][j]=1且M[j][k]=1则M[i][k]=1 |

**输入示例**（等价关系）：
```
输入集合A的元素个数: 3
依次输入集合A的各元素 (空格分隔，可以是数字或字母): a b c

输入关系R中序偶的个数: 5
输入关系的序偶 (格式: a b):
第1个序偶: a a
第2个序偶: a b
第3个序偶: b a
第4个序偶: b b
第5个序偶: c c
```

**输出示例**：
```
【关系矩阵 M(R)】
       a    b    c
  a    1    1    0
  b    1    1    0
  c    0    0    1

【关系性质判断】
(1) 自反关系: 是
(2) 反自反关系: 否
(3) 对称关系: 是
(4) 反对称关系: 否
(5) 传递关系: 否
```

---

### 实验3：关系的复合运算 (`exp3_关系复合.c`)

**功能**：
- 输入集合A、B、C
- 输入关系R（从A到B）
- 输入关系S（从B到C）
- 计算并输出复合关系R∘S的矩阵

**复合公式**：
$$R \circ S = \{<a,c> | \exists b \in B, <a,b> \in R \land <b,c> \in S\}$$

**矩阵计算**：
$$M(R \circ S)[i][k] = \bigvee_{j} (M(R)[i][j] \land M(S)[j][k])$$

**输入示例**：
```
========================================
实验三：关系的复合运算
========================================

输入关系R的信息:
集合A元素个数: 2
输入集合A的元素 (空格分隔，可以是数字或字母): a b
集合B元素个数: 3
输入集合B的元素 (空格分隔，可以是数字或字母): 1 2 3
关系R的序偶个数: 2
输入R的序偶 (格式: a b):
第1个: a 1
第2个: a 2

输入关系S的信息:
集合C元素个数: 2
输入集合C的元素 (空格分隔，可以是数字或字母): x y
关系S的序偶个数: 3
输入S的序偶 (格式: b c):
第1个: 1 x
第2个: 2 y
第3个: 3 x

========================================
```

**输出示例**：
```
========================================

【R的关系矩阵】
          1     2     3
  a      1     1     0
  b      0     0     0

【S的关系矩阵】
          x     y
  1      1     0
  2      0     1
  3      1     0

【R∘S的关系矩阵】
          x     y
  a      1     1
  b      0     0
========================================
```

---

### 实验4：关系的闭包 (`exp4_关系闭包.c`)

**功能**：
- 输入集合A和A上的关系R
- 计算并输出：
  - 自反闭包：r(R) = R ∪ {<a,a> | a∈A}
  - 对称闭包：s(R) = R ∪ {<b,a> | <a,b>∈R}

**闭包的意义**：
- 自反闭包：加入所有自环使关系具有自反性
- 对称闭包：加入反向的边使关系具有对称性

**输入示例**：
```
输入集合A的元素个数: 3
依次输入集合A的各元素 (空格分隔): a b c

输入关系R中序偶的个数: 3
输入关系的序偶 (格式: a b):
第1个序偶: a b
第2个序偶: b c
第3个序偶: a c
```

**输出示例**：
```
【原关系R的矩阵 M(R)】
       a    b    c
  a    0    1    1
  b    0    0    1
  c    0    0    0

【自反闭包 r(R) 的矩阵 M(r(R))】
(在R的基础上，主对角线全变为1)
       a    b    c
  a    1    1    1
  b    0    1    1
  c    0    0    1

【对称闭包 s(R) 的矩阵 M(s(R))】
(在R的基础上，加入所有反向的边)
       a    b    c
  a    0    1    1
  b    1    0    1
  c    1    1    0
```

---

### 实验5：函数的定义与类型 (`exp5_函数判定.c`)

**功能**：
- 输入集合A和集合B
- 输入关系f（从A到B）
- 判定并输出：
  - 是否为函数
  - 是否为单射（一对一）
  - 是否为满射（映上）
  - 函数类型分类

**函数类型**：

| 类型 | 条件 | 说明 |
|------|------|------|
| 函数 | A中每个元素恰好对应B中一个元素 | 定义域=A，每个输入一个输出 |
| 单射 | 不同的A中元素映射到不同的B中元素 | 一对一 |
| 满射 | B中每个元素都被某个A中元素映射到 | 映上 |
| 双射 | 既是单射又是满射 | 一一对应，存在反函数 |

**输入示例**（双射）：
```
输入集合A的元素个数: 3
依次输入集合A的各元素 (空格分隔): a b c
输入集合B的元素个数: 3
依次输入集合B的各元素 (空格分隔): 1 2 3

输入函数f的像对个数: 3
输入函数的像对 (格式: a b):
第1个像对: a 1
第2个像对: b 2
第3个像对: c 3
```

**输出示例**：
```
【函数f的集合表达式】
f = {<a,1>, <b,2>, <c,3>}

【函数矩阵 M(f)】
       1    2    3
  a    1    0    0
  b    0    1    0
  c    0    0    1

【函数类型判断】
(1) 是函数: 是（A中每个元素都恰好映射到B中一个元素）
(2) 是单射: 是（不同的A中元素映射到B中不同的元素）
(3) 是满射: 是（B中每个元素都被A中某个元素映射到）
(4) 类型: 双射（既是单射又是满射）
```

**输入示例**（非双射）：
```
输入集合A的元素个数: 3
依次输入集合A的各元素 (空格分隔): a b c
输入集合B的元素个数: 3
依次输入集合B的各元素 (空格分隔): 1 2 3

输入函数f的像对个数: 3
输入函数的像对 (格式: a b):
第1个像对: a 1
第2个像对: b 1
第3个像对: c 2
```

**输出示例**：
```
【函数f的集合表达式】
f = {<a,1>, <b,1>, <c,2>}

【函数矩阵 M(f)】
       1    2    3
  a    1    0    0
  b    1    0    0
  c    0    1    0

【函数类型判断】
(1) 是函数: 是（A中每个元素都恰好映射到B中一个元素）
(2) 是单射: 否（a和b都映射到1）
(3) 是满射: 否（3没有被任何元素映射到）
(4) 类型: 一般函数
```

---

## 💻 编译和运行

### 在Dev-C++中
1. File → Open → 选择 .c 文件
2. Execute → Compile & Run (或按F11)

### 使用命令行

**GCC编译**：
```bash
gcc -std=c99 -o exp1.exe exp1_关系概念.c
./exp1.exe
```

**MSVC编译**：
```bash
cl exp1_关系概念.c
exp1_关系概念.exe
```

---

## 📝 输入格式

### 输入集合（支持数字和字母）
```
输入集合的元素个数: 3
依次输入集合的各元素 (空格分隔，可以是数字或字母): a b c
```

或使用数字：
```
输入集合的元素个数: 3
依次输入集合的各元素 (空格分隔，可以是数字或字母): 1 2 3
```

### 输入序偶（**重要：格式为 "a b"，两个元素间用空格分隔**）
```
输入关系R中序偶的个数: 3
输入关系的序偶 (格式: a b，两个元素用空格分隔):
第1个序偶: a b
第2个序偶: b c
第3个序偶: a c
```

**⚠️ 常见错误**：
- ❌ `1 2 3` - 错误！输入了3个元素
- ❌ `a1` - 错误！没有空格分隔
- ✅ `a b` - 正确！两个元素用空格分隔
- ✅ `1 2` - 正确！两个元素用空格分隔

如果输入格式不对，程序会提示：`[错误] 输入格式不正确，请输入两个元素（如: a b）`，请重新输入该序偶。

---

## 🔍 常见问题

### Q1: 输入序偶时出现 "[错误] 输入格式不正确"
**A**: 序偶必须是 **两个元素用空格分隔** 的格式：
- ❌ 错误：`1 2 3` （3个元素）
- ❌ 错误：`a1` （没有空格）
- ✅ 正确：`a b` （两个元素，空格分隔）

重新输入时按照提示格式：`a b` 或 `1 2`

### Q2: 输入序偶时出现 "[错误] ... 不在集合A中"
**A**: 序偶中的元素必须在对应的集合中：
- exp1：第一个元素必须在集合A中，第二个必须在集合B中
- exp2：两个元素都必须在集合A中
- 例如：如果集合A = {a, b, c}，则不能输入 <d, a>

### Q3: 支持哪些元素？
**A**: 任何单个字符都支持，包括：
- 小写字母: a-z
- 大写字母: A-Z
- 数字字符: 0-9
- 其他单字符: !, @, #, 等

### Q4: 编译出错 "for loop initial declarations are only allowed in C99"
**A**: 在Dev-C++中设置编译选项为C99：
- Tools → Compiler Options
- 在编译参数中添加 `-std=c99`
- 或改为：`gcc -std=c99 exp1_关系概念.c`

### Q5: 程序输出乱码
**A**: 
- 检查源文件编码：应为UTF-8或GBK
- 在Dev-C++中：File → Properties → 设置编码

### Q6: 支持的最大集合大小
**A**: 最多50个元素，最多100个序偶

---

## 🧪 测试示例

### 字母元素示例（exp1）
```
集合A: 3个元素 → a b c
集合B: 3个元素 → x y z
序偶: 3个 → <a,x>, <b,y>, <c,z>

输出矩阵：
       x    y    z
  a    1    0    0
  b    0    1    0
  c    0    0    1
```

### 数字元素示例（exp1）
```
集合A: 2个元素 → 1 2
集合B: 2个元素 → 1 2
序偶: 2个 → <1,1>, <2,2>

输出矩阵：
       1    2
  1    1    0
  2    0    1
```

### 等价关系示例（exp2）
```
集合A: 3个元素 → a b c
关系R（5个序偶）：
  <a,a>, <a,b>, <b,a>, <b,b>, <c,c>

输出矩阵：
       a    b    c
  a    1    1    0
  b    1    1    0
  c    0    0    1

关系性质：
(1) 自反关系: 是
(2) 反自反关系: 否
(3) 对称关系: 是
(4) 反对称关系: 否
(5) 传递关系: 否
```

### 反对称关系示例（exp2）
```
集合A: 3个元素 → 1 2 3
关系R（3个序偶）：
  <1,1>, <1,2>, <2,2>

关系性质：
(1) 自反关系: 否
(2) 反自反关系: 否
(3) 对称关系: 否
(4) 反对称关系: 是 ✓（偏序关系）
(5) 传递关系: 是 ✓
```

### 双射函数示例（exp5）
```
集合A: 3个元素 → a b c
集合B: 3个元素 → 1 2 3
f: 3个序偶 → <a,1>, <b,2>, <c,3>
结果: 函数✓ 单射✓ 满射✓ 双射✓
```

---

## � 实验对比：exp1 vs exp2

| 特性 | exp1（关系概念） | exp2（关系性质） |
|------|-----------------|-----------------|
| **集合个数** | 2个（A和B） | 1个（只有A） |
| **关系类型** | A到B的关系 | A上的自身关系 |
| **序偶元素** | `<a, b>`：a∈A, b∈B | `<a, b>`：a,b都∈A |
| **矩阵维度** | m×n（可不同） | n×n（方阵） |
| **输出内容** | 集合表达式、矩阵、定义域、值域 | 矩阵、5种性质判定 |
| **主要功能** | 理解关系的表示 | 判定关系的性质 |

**关键区别**：
- exp1 要输入**两个不同的集合**（A和B）
- exp2 只输入**一个集合**（A），关系是A到自身的

---

## �📚 关键概念

### 关系的表示
- **序偶形式**: R = {<a₁,b₁>, <a₂,b₂>, ...}
- **矩阵形式**: M(R)[i][j] = 1 当<aᵢ,bⱼ>∈R，否则=0
- **定义域**: domR = {第一个分量的集合}
- **值域**: ranR = {第二个分量的集合}

### 特殊关系
- **等价关系**: 自反 + 对称 + 传递
- **偏序关系**: 自反 + 反对称 + 传递
- **严格偏序**: 反自反 + 反对称 + 传递

### 闭包运算
- **r(R)** = 自反闭包 = R ∪ {<a,a> | a∈A}
- **s(R)** = 对称闭包 = R ∪ R⁻¹
- **t(R)** = 传递闭包 = R ∪ R² ∪ R³ ∪ ...

---

## ✅ 代码特性

✅ **标准C89兼容** - 可在任何C编译器上运行  
✅ **支持字母和数字输入** - a-z, A-Z, 0-9 等单字符元素  
✅ **矩阵输出对齐** - 清晰整齐的矩阵显示  
✅ **中文注释和输出** - 易于理解  
✅ **错误检验** - 序偶有效性检查  
✅ **独立程序** - 每个实验可单独运行  

---

## 🎓 学习路径

### 初级
1. 运行 exp1，理解关系的表示方法
2. 运行 exp5，理解函数的概念

### 中级
3. 运行 exp2，学习5种关系性质
4. 自己设计满足特定性质的关系

### 高级
5. 运行 exp3，理解关系的复合
6. 运行 exp4，理解闭包操作
7. 综合应用多个概念

---

## 📞 技术支持

遇到问题？
1. 检查输入格式是否正确
2. 确保编译时使用 `-std=c99` 或 `-std=c11`
3. 验证源文件编码为UTF-8
4. 参考本README中的示例

---

## 📊 项目统计

| 指标 | 数值 |
|------|------|
| 实验数量 | 5个 |
| 源代码文件 | 5个 |
| 总代码行数 | ~1200行 |
| 最大集合元素 | 50个 |
| 最大序偶数 | 100个 |
| 判定算法 | 8种 |
| 关键功能 | 15+个 |

---

## ✨ 快速参考

### 编译命令
```bash
# GCC (推荐)
gcc -std=c99 -o exp1.exe exp1_关系概念.c

# MinGW
mingw32-gcc -std=c99 -o exp1.exe exp1_关系概念.c

# Clang
clang -std=c99 -o exp1.exe exp1_关系概念.c
```

### 快捷方式
- **在Dev-C++中运行**: F11
- **仅编译**: F9
- **调试运行**: F10

### 矩阵读法
- 行表示第一个集合的元素
- 列表示第二个集合的元素
- M[i][j]=1 表示存在<aᵢ,bⱼ>的关系

---

## 📖 收获与体会

通过这五个离散数学实验的实现，我们深刻理解了关系与函数的核心概念：

### 理论认识
- **关系的本质**：关系是集合间有序对的集合，通过矩阵和图论可以直观地表示和分析
- **性质的判定**：5种关系性质（自反、反自反、对称、反对称、传递）的判定条件不仅是定义，更是实际问题中的重要特征
- **运算的应用**：关系的复合运算体现了函数复合的数学思想，在计算机科学中广泛应用于状态转移、路径查找等问题
- **闭包的意义**：闭包运算将非自反或非对称的关系补充完整，是数据结构设计中的重要概念

### 编程实践
- **C语言数据结构设计**：通过结构体与数组的组合，实现了离散数学中的抽象概念
- **矩阵运算的实现**：二维数组的矩阵表示方法，为后续线性代数、图论等课程打下基础
- **输入验证与容错**：通过fgets+sscanf的输入模式，提高了程序的稳定性和用户体验
- **算法复杂度**：关系性质的判定涉及多重循环，理解了时间复杂度的概念

### 数学应用
- **等价关系**：在实际中，相同的数据类型、相同年龄的学生等都构成等价关系
- **函数分类**：单射、满射、双射在数据结构（哈希表、映射）中都有实际应用
- **关系闭包**：在社交网络中，"朋友的朋友"就是对称闭包；在项目管理中，任务依赖关系的传递闭包指出了关键路径

### 综合收获
这个项目不仅巩固了离散数学的理论知识，更重要的是通过编程实现，将抽象的数学概念转化为具体的可运行的代码。这种理论与实践相结合的学习方式，让我们真正理解了数学在计算机科学中的核心地位。

---

**祝您实验顺利！** 🎉

*最后更新：2025年11月11日*
*版本：2.0 - 添加字母输入支持和矩阵对齐优化*
*C标准：C89/C99/C11兼容*
*编码：UTF-8*
*特性：支持任意单字符元素（字母/数字）*
